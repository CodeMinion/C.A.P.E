<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
	<script src="fabric.min.js"></script>
	<script src="jquery-3.3.1.min.js"></script>
	<title>Hello World!</title>

  </head>
  <body>
    <h1>Hello World!</h1>
    We are using node <script>document.write(process.versions.node)</script>,
    Chrome <script>document.write(process.versions.chrome)</script>,
    and Electron <script>document.write(process.versions.electron)</script>.
	<button id="party" class="very-sweet-looking">Open</button>
	
	<center>
	 <div id="app">
            Current Zoom: <span style="font-weight: bold;" id="current-value"></span>

            <br />
            <input type="range" id="zoom" min="20" value="100" max="200" step="10">
    </div>
	
	<canvas id="c" width="200" height="100"></canvas>
	</center>
	
<script>
const {ipcRenderer} = require('electron');
var canvas = new fabric.Canvas('c', { selection: false });
var zoomFactor; 
var zoomControl; 
var activeComicData;

const zoomMin = 20, zoomMax = 200, zoomStep = 10; 
let zoomLevelSpan = document.getElementById("current-value");

// Initialize Mouse Controls
//initControls(canvas);


document.getElementById("zoom").addEventListener("input", function(){
	var value = this.value;
	updateZoomWidget(value);
}, false);

function getCurrentZoom()
{
	document.getElementById("zoom").value;
}

/**
function zoomOut()
{
	var zoom = getCurrentZoom();
	zoom -= zoomStep;
	
	if(zoom <= zoomMin)
	{
		zoom = zoomMin;
	}
	
	updateZoomWidget(zoom);
	
	console.log(zoom);
}

function zoomIn()
{
	var zoom = getCurrentZoom();
	zoom += zoomStep;
	
	if(zoom >= zoomMax)
	{
		zoom = zoomMax;
	}
	
	updateZoomWidget(zoom);

}

*/

function updateZoomWidget(value)
{
	// Update label
    zoomLevelSpan.innerHTML = value + "%";
	zoomFactor = value / 100;
	performZoom(zoomFactor);

}

document.addEventListener('DOMContentLoaded', function(){
	//zoomLevelSpan.innerHTML = getFactorInPercent(webFrame.getZoomFactor());
	zoomControl = document.getElementById("zoom");
}, false);

/**
 Zooms the canvas to the percentage specified. 
 Range: 0 - 1;
 */
function performZoom(value)
{
	img = canvas.item(0);
	canvas.setZoom(zoomFactor);
	canvas.setHeight(img.height * value);
	canvas.setWidth(img.width * value);
    
}

//canvas.setHeight(1500);
//canvas.setWidth(1500);
canvas.backgroundColor="red";
//canvas.setBackgroundImage('file://C:\\Users\\CodeMinion\\Desktop\\ComicsFolder\\Scott\'s Comics\\...And Ive got a thing for you too\\2013.06.01-Sloan_p01.jpg');



document.addEventListener('DOMContentLoaded',pageLoaded);
// Register to perform doSomething when receiving Back_To_You from the main process.
ipcRenderer.on('Back_To_You', doSomething);
function doSomething(event, data)
{
	alert('Python Completed');
	console.log("Got: "+ data);
}
 function pageLoaded(){
     //alert('The page is loade');
     ipcRenderer.send('Am_I_Ready',"Im ready");
 }
 

ipcRenderer.on('EVENT_LOAD_PANEL', loadComicPanel);
//ipcRenderer.on('KEYBORAD_KEY_STATE_CHANGED', handleKeyEvent);

function loadComicPanel(event, comicMetadataInfo)
 {
    //alert('I got you -' + msg);
	var filePath = comicMetadataInfo.imagePath; 
	console.log(filePath);
	
	var link = 'file://'+filePath;
	
	fabric.Image.fromURL(link, function(img) {
    img.set({
        id : 'comic_panel',//'image_'+index,
		borderColor: 'gray',
        //width : canvas.width / 2,
        //height : canvas.height / 2
    });
	
	
	// Write Metadata to the system if any exists.
	savePanelDataHelper(activeComicData);
	/*
	if (activeComicData)
	{
		console.log("Saving Metadata");
		// Write metadata file. 
		// 1- Update comic metadata with current shapes.
		var updatedComicData = updateComicData(activeComicData, canvas);
		console.log(updatedComicData.metadata.panels);
		// 2- Write it to file. 
		//REQUEST_COMIC_METADATA_STORE
		mainProcess.saveComicPageMetadata(updatedComicData);
		//ipcRenderer.send('REQUEST_COMIC_METADATA_STORE', updatedComicData);
	}
	*/
	
	// Prepare canvas for picture.
	canvas.clear();
	var value = 100;
	zoomLevelSpan.innerHTML = value + "%";
	document.getElementById("zoom").value = value;
	canvas.setZoom(1);
	
	//
	
	/*
	img.lockRotation = true;
	img.lockScaling = true;
	img.lockMovementX = img.lockMovementY = true;
	img.lockScalingX = img.lockScalingY = true;
	*/
	img.selectable = false;
	img.hasControls = false;
	
	canvas.add(img);
	// Ensure that comic page is not overlaid over the panels.
	
	canvas.sendToBack(img);
	var panels = comicMetadataInfo.metadata.panels;
	for (panelInfo in panels)
	  {
		 box = 	panels[panelInfo].box;
		 
		 var rect = new fabric.Rect({
		  left: box.x,
		  top: box.y,
		  fill: 'green',
		  width: box.w,
		  height: box.h
		});
		rect.borderColor = 'gray';
		rect.cornerColor = 'black';
		
		rect.opacity=0.3;
		rect.lockRotation = true;
	
		canvas.add(rect)
		console.log(box);
	  }
	canvas.setHeight(img.height * img.scaleY);
	canvas.setWidth(img.width * img.scaleX);
    canvas.renderAll();
	
	activeComicData = comicMetadataInfo;
	});
 } 
 
 function savePanelDataHelper(activeComicData)
 {
	if (activeComicData)
	{
		var updatedComicData = updateComicData(activeComicData, canvas);
		console.log(updatedComicData.metadata.panels);
		mainProcess.saveComicPageMetadata(updatedComicData);
	}		
 }
 
 ipcRenderer.on('SAVE_PANEL_DATA', performComicPanelSave);
 
 function performComicPanelSave()
 {
	savePanelDataHelper(activeComicData);
 }
 
 
 /**
  Updates the comic data with the panel information from the canvas. 
  */
function updateComicData(comicMetadataInfo, canvas)
{
	var panels = [];//comicMetadataInfo.metadata.panels;
	
	var scaleIt = function(prop)
	{
		if(!prop)
		{
			return 1;
		}
            return parseFloat(prop, 10);
          };
		  
	canvas.forEachObject(function(obj)
	{
		var objId = obj.get('id');
		
		if(objId == 'comic_panel')
		{
			return;
		}	
		console.log(obj);
		
        var currentObjTop = obj.get('top'),
            currentObjLeft = obj.get('left'),
			currentObjWidth = obj.get('width'),
			currentObjHeight = obj.get('height'),
			currentObjScaleX = obj.get('scaleX'),
            currentObjScaleY = obj.get('scaleY'),
			scaledObjScaleX = scaleIt(currentObjScaleX),
            scaledObjScaleY = scaleIt(currentObjScaleY);
        
		
		var boxData = {
			x: currentObjLeft,
			y: currentObjTop,
			w: currentObjWidth * scaledObjScaleX,
			h: currentObjHeight * scaledObjScaleY
		};
		
		// Shapes not supported yet.
		shapeData = [];
		
		var panelInfo = {
			box: boxData,
			shape: shapeData
		};
		
		panels.push(panelInfo);
     
	
	 });
	 
	 comicMetadataInfo.metadata.panels = panels;
	 
	 return comicMetadataInfo;
} 
 /**
 Function to handle the displaying of a panel and it's metadata.
 **/
 
 /**
  Helper function to scale everything inside a given canvas. 
  Adapter from: https://gist.github.com/jefflembeck/e4d088d64d3f98ea85cc
  */
 function scaleAll(canvas, value){
      var self = canvas,
          scaleIt = function(prop){
            return parseFloat(prop, 10) * value;
          };

      var currentCanvasHeight = self.getHeight(),
          currentCanvasWidth  = self.getWidth(),
          scaledCanvasHeight  = scaleIt(currentCanvasHeight),
          scaledCanvasWidth   = scaleIt(currentCanvasWidth);


      self.forEachObject(function(obj){
        var currentObjTop = obj.get('top'),
            currentObjLeft = obj.get('left'),
            currentObjScaleX = obj.get('scaleX'),
            currentObjScaleY = obj.get('scaleY'),
            scaledObjTop = scaleIt(currentObjTop),
            scaledObjLeft = scaleIt(currentObjLeft),
            scaledObjScaleX = scaleIt(currentObjScaleX),
            scaledObjScaleY = scaleIt(currentObjScaleY);

        obj.set({
          top: scaledObjTop,
          left: scaledObjLeft,
          scaleX: scaledObjScaleX,
          scaleY: scaledObjScaleY
        });
        obj.setCoords();

      });

      self.scaleValue = value;
      self.renderAll();
    }
 

// Use this to call method on other JS files including main/index
const electron = require('electron')
const remote = electron.remote
const mainProcess = remote.require('./index')

//const mainProcess = remote.require('./main')
document.getElementById('party').addEventListener('click', _ => {
  // Call method on JS.
  mainProcess.selecComicPage()
})

window.addEventListener('keyup', handleKeyEvent, true);
window.addEventListener('keydown', handleKeyEvent, true);
  
function handleKeyEvent(event)
{
	console.log(event);
	
	isControlDown = event.ctrlKey;
	
	if(event.key=='Delete')
	{
		var activeObj = canvas.getActiveObject();
		canvas.remove(activeObj);
	}
	/**
	else if(event.key == '+')
	{
		zoomIn();
	}
	else if(event.key == '-')
	{
		zoomOut();
	}
	**/
	
}
/**
Logic for creating Rectangles via mouse down.
Modified from Source: http://jsfiddle.net/a7mad24/aPLq5/
*/ 
var rect, isDown, origX, origY, isControlDown = false, createdRect;

canvas.on('mouse:down', function(o){

	if(isControlDown)
	{
		isDown = true;
		var pointer = canvas.getPointer(o.e);
		origX = pointer.x;
		origY = pointer.y;
		var pointer = canvas.getPointer(o.e);
		rect = new fabric.Rect({
			left: origX,
			top: origY,
			originX: 'left',
			originY: 'top',
			width: pointer.x-origX,
			height: pointer.y-origY,
			//angle: 0,
			fill: 'rgba(255,0,0,0.5)',
			//transparentCorners: false
		});
		
		rect.lockRotation = true;
		rect.selectable = true;
		rect.hasControls = true;
		createdRect = rect; 
		canvas.add(rect);
		
	}
});

canvas.on('mouse:move', function(o){
    if (!isDown) return;
    var pointer = canvas.getPointer(o.e);

    if(origX>pointer.x){
        rect.set({ left: Math.abs(pointer.x) });
    }
    if(origY>pointer.y){
        rect.set({ top: Math.abs(pointer.y) });
    }

    rect.set({ width: Math.abs(origX - pointer.x) });
    rect.set({ height: Math.abs(origY - pointer.y) });
	rect.setCoords();
	canvas.renderAll();
});

canvas.on('mouse:up', function(o){
  isDown = false;
  
  if(createdRect)
  {
	canvas.setActiveObject(createdRect);	 
	canvas.bringToFront(rect);	
	createdRect = null;
  }
});

 
</script>

  </body>
</html>